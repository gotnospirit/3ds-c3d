#include <stdio.h>
#include <3ds.h>
#include <citro3d.h>

#include <string.h>
#include <stdlib.h>

#define STBI_NO_STDIO
#define STBI_ONLY_PNG
// #define STBI_ONLY_JPEG
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

// These headers are generated by the build process
#include "vshader_shbin.h"
#include "spritesheet_png.h"

#define CLEAR_COLOR 0x000000FF

// Used to transfer the final rendered display to the framebuffer
#define DISPLAY_TRANSFER_FLAGS \
    (GX_TRANSFER_FLIP_VERT(0) | GX_TRANSFER_OUT_TILED(0) | GX_TRANSFER_RAW_COPY(0) | \
    GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGB8) | \
    GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

// Used to convert textures to 3DS tiled format
// Note: vertical flip flag set so 0,0 is top left of texture
#define TEXTURE_TRANSFER_FLAGS \
    (GX_TRANSFER_FLIP_VERT(1) | GX_TRANSFER_OUT_TILED(1) | GX_TRANSFER_RAW_COPY(0) | \
    GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGBA8) | \
    GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

#define CLAMP(value, min, max) ((value < min) ? min : (value > max) ? max : value)

typedef struct
{
    int width, height, real_width, real_height;
    C3D_Tex ptr;
} Texture;

typedef struct
{
    int x, y, width, height;
} Sprite;

typedef struct
{
    float left, top, right, bottom;
} Frame;

u32 next_pow_2(u32 i)
{
    i--;
    i |= i >> 1;
    i |= i >> 2;
    i |= i >> 4;
    i |= i >> 8;
    i |= i >> 16;
    i++;

    return (i < 64)
        ? 64 : i;
}

float easeLinear(int t, float b, float c, int d)
{
    return c * t / d + b;
}

void updateChip(Sprite * chip, circlePosition const * pos)
{
    // Print the CirclePad position
    int incr = 5;

    int dx = pos->dx;
    int dy = pos->dy;

    float x_incr = dx * incr / 160;
    float y_incr = dy * incr / 160;

    y_incr *= -1;

    chip->x += x_incr;
    chip->y += y_incr;

    chip->x = CLAMP(chip->x, 0, 400 - chip->width);
    chip->y = CLAMP(chip->y, 0, 240 - chip->height);

    printf("\x1b[0;0H%04d; %04d", pos->dx, pos->dy);
}

void setChipsFrames(Texture const * spritesheet, Frame * frames)
{
    float texture_width = (float)spritesheet->width / spritesheet->real_width;
    float texture_height = (float)spritesheet->height / spritesheet->real_height;

    int nb_cols = 6, nb_rows = 3;

    float sprite_width = texture_width / nb_cols;
    float sprite_height = texture_height / nb_rows;

    float left = 0, top = 0;
    for (int i = 0; i < 18; ++i)
    {
        left = (i % nb_cols) * sprite_width;
        top = (int)(i / nb_cols) * sprite_height;

        frames[i].left = left;
        frames[i].top = top;
        frames[i].right = left + sprite_width;
        frames[i].bottom = top + sprite_height;
    }
}

void draw_quad(float x1, float y1, float x2, float y2, float tx1, float ty1, float tx2, float ty2)
{
    C3D_ImmDrawBegin(GPU_TRIANGLES);

    C3D_ImmSendAttrib(x1, y1, 0.5f, 0.0f);
    C3D_ImmSendAttrib(tx1, ty1, 0.0f, 0.0f);

    C3D_ImmSendAttrib(x2, y2, 0.5f, 0.0f);
    C3D_ImmSendAttrib(tx2, ty2, 0.0f, 0.0f);

    C3D_ImmSendAttrib(x2, y1, 0.5f, 0.0f);
    C3D_ImmSendAttrib(tx2, ty1, 0.0f, 0.0f);

    C3D_ImmSendAttrib(x1, y1, 0.5f, 0.0f);
    C3D_ImmSendAttrib(tx1, ty1, 0.0f, 0.0f);

    C3D_ImmSendAttrib(x1, y2, 0.5f, 0.0f);
    C3D_ImmSendAttrib(tx1, ty2, 0.0f, 0.0f);

    C3D_ImmSendAttrib(x2, y2, 0.5f, 0.0f);
    C3D_ImmSendAttrib(tx2, ty2, 0.0f, 0.0f);

    C3D_ImmDrawEnd();
}

static DVLB_s * vshader_dvlb;
static shaderProgram_s program;
static int uLoc_projection;
static C3D_Mtx projection;

static void loadPNG(Texture * texture, u8 const * data, u32 size, int id)
{
    unsigned char * image;
    int width, height;
    int bpp;

    image = stbi_load_from_memory(data, size, &width, &height, &bpp, 0);

    u32 pow2Width = next_pow_2(width);
    u32 pow2Height = next_pow_2(height);

    u32 texture_size = pow2Width * pow2Height * 4;
    u8 * gpusrc = linearAlloc(texture_size);
    memset(gpusrc, 0, texture_size);

    // GX_DisplayTransfer needs input buffer in linear RAM
    // lodepng outputs big endian rgba so we need to convert
    for (int x = 0; x < width; x++)
    {
        for (int y = 0; y < height; y++)
        {
            u32 imagePos = (y * width + x) * 4;
            u32 gpuTexPos = (y * pow2Width + x) * 4;

            gpusrc[gpuTexPos + 0] = image[imagePos + 3];
            gpusrc[gpuTexPos + 1] = image[imagePos + 2];
            gpusrc[gpuTexPos + 2] = image[imagePos + 1];
            gpusrc[gpuTexPos + 3] = image[imagePos + 0];
        }
    }

    // ensure data is in physical ram
    GSPGPU_FlushDataCache(gpusrc, texture_size);

    C3D_TexInit(&texture->ptr, pow2Width, pow2Height, GPU_RGBA8);

    // Convert image to 3DS tiled texture format
    u32 dim = GX_BUFFER_DIM(pow2Width, pow2Height);
    GX_DisplayTransfer(
        (u32 *)gpusrc, dim,
        (u32 *)texture->ptr.data, dim,
        TEXTURE_TRANSFER_FLAGS
    );
    gspWaitForPPF();

    C3D_TexSetFilter(&texture->ptr, GPU_LINEAR, GPU_NEAREST);
    C3D_TexBind(id, &texture->ptr);

    stbi_image_free(image);
    linearFree(gpusrc);

    texture->width = width;
    texture->height = height;
    texture->real_width = pow2Width;
    texture->real_height = pow2Height;

    // Configure buffers
    // C3D_BufInfo * bufInfo = C3D_GetBufInfo();
    // BufInfo_Init(bufInfo);

    // Configure the first fragment shading substage to just pass through the texture color
    // See https://www.opengl.org/sdk/docs/man2/xhtml/glTexEnv.xml for more insight
    C3D_TexEnv * env = C3D_GetTexEnv(id);
    C3D_TexEnvSrc(env, C3D_Both, GPU_TEXTURE0, 0, 0);
    C3D_TexEnvOp(env, C3D_Both, 0, 0, 0);
    C3D_TexEnvFunc(env, C3D_Both, GPU_REPLACE);
}

static void sceneInit(void)
{
    // Load the vertex shader, create a shader program and bind it
    vshader_dvlb = DVLB_ParseFile((u32 *)vshader_shbin, vshader_shbin_size);
    shaderProgramInit(&program);
    shaderProgramSetVsh(&program, &vshader_dvlb->DVLE[0]);
    C3D_BindProgram(&program);

    // Get the location of the uniforms
    uLoc_projection = shaderInstanceGetUniformLocation(program.vertexShader, "projection");

    // Configure attributes for use with the vertex shader
    // Attribute format and element count are ignored in immediate mode
    C3D_AttrInfo * attrInfo = C3D_GetAttrInfo();
    AttrInfo_Init(attrInfo);
    AttrInfo_AddLoader(attrInfo, 0, GPU_FLOAT, 3); // v0=position
    AttrInfo_AddLoader(attrInfo, 1, GPU_FLOAT, 2); // v2=texcoord

    // Compute the projection matrix
    // Note: we're setting top to 240 here so origin is at top left.
    Mtx_OrthoTilt(&projection, 0.0, 400.0, 240.0, 0.0, 0.0, 1.0);

    // Configure depth test to overwrite pixels with the same depth (needed to draw overlapping sprites)
    C3D_DepthTest(true, GPU_GEQUAL, GPU_WRITE_ALL);

    // Update the uniforms
    C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
}

static void sceneRender(Sprite const * chip, Frame const * frames, u64 elapsed, float offset3d)
{
    int idx = easeLinear(elapsed % 1000, 0, 18, 1000);
    Frame const frame = frames[idx];

    float x = chip->x + offset3d;
    draw_quad(
        x, chip->y, x + chip->width, chip->y + chip->height,
        frame.left, frame.top, frame.right, frame.bottom
    );
}

static void sceneExit(Texture * spritesheet)
{
    // Free the shader program
    shaderProgramFree(&program);
    DVLB_Free(vshader_dvlb);

    C3D_TexDelete(&spritesheet->ptr);
}

int main(int argc, char ** argv)
{
    // Initialize graphics
    gfxInitDefault();
    gfxSet3D(true);

    C3D_Init(C3D_DEFAULT_CMDBUF_SIZE);

    // Initialize the render target
    C3D_RenderTarget * top_left = C3D_RenderTargetCreate(240, 400, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
    C3D_RenderTargetSetClear(top_left, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
    C3D_RenderTargetSetOutput(top_left, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);

    C3D_RenderTarget * top_right = C3D_RenderTargetCreate(240, 400, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
    C3D_RenderTargetSetClear(top_right, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
    C3D_RenderTargetSetOutput(top_right, GFX_TOP, GFX_RIGHT, DISPLAY_TRANSFER_FLAGS);

    consoleInit(GFX_BOTTOM, NULL);
    printf("\x1b[15;10HPress Start to exit.");

    Sprite chip;
    chip.width = 45;
    chip.height = 45;
    chip.x = (400 - chip.width) / 2;
    chip.y = (240 - chip.height) / 2;

    Texture spritesheet;
    loadPNG(&spritesheet, spritesheet_png, spritesheet_png_size, 0);

    Frame frames[18];
    setChipsFrames(&spritesheet, frames);

    // Initialize the scene
    sceneInit();

    circlePosition pos;

    // Main loop
    u64 start = osGetTime();
    while (aptMainLoop())
    {
        hidScanInput();

        // Respond to user input
        u32 kDown = hidKeysDown();
        if (kDown & KEY_START)
        {
            break; // break in order to return to hbmenu
        }

        //Read the CirclePad position
        hidCircleRead(&pos);

        updateChip(&chip, &pos);

        u64 elapsed = osGetTime() - start;

        float iod = osGet3DSliderState() * 15;
        if (iod > 0.0f)
        {
            printf("\x1b[1;0H3D enabled ");
        }
        else
        {
            printf("\x1b[1;0H3D disabled");
        }

        // Render the scene
        C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
        {
            if (iod > 0.0f)
            {
                C3D_FrameDrawOn(top_left);
                sceneRender(&chip, frames, elapsed, -iod);

                C3D_FrameDrawOn(top_right);
                sceneRender(&chip, frames, elapsed, iod);
            }
            else
            {
                C3D_FrameDrawOn(top_left);
                sceneRender(&chip, frames, elapsed, 0);
            }
        }
        C3D_FrameEnd(0);
    }

    // Deinitialize the scene
    sceneExit(&spritesheet);

    C3D_RenderTargetDelete(top_left);
    C3D_RenderTargetDelete(top_right);

    // Deinitialize graphics
    C3D_Fini();
    gfxExit();
    return 0;
}
