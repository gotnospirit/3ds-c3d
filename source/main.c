#include <stdio.h>
#include <3ds.h>
#include <citro3d.h>

#include <string.h>
#include <stdlib.h>

#define STBI_NO_STDIO
#define STBI_ONLY_PNG
#define STBI_ONLY_JPEG
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

// These headers are generated by the build process
#include "vshader_shbin.h"
#include "spritesheet_png.h"
#include "expresso_jpg.h"

#define CLEAR_COLOR 0x000000FF

// Used to transfer the final rendered display to the framebuffer
#define DISPLAY_TRANSFER_FLAGS \
    (GX_TRANSFER_FLIP_VERT(0) | GX_TRANSFER_OUT_TILED(0) | GX_TRANSFER_RAW_COPY(0) | \
    GX_TRANSFER_IN_FORMAT(GX_TRANSFER_FMT_RGBA8) | GX_TRANSFER_OUT_FORMAT(GX_TRANSFER_FMT_RGB8) | \
    GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

// Used to convert textures to 3DS tiled format
// Note: vertical flip flag set so 0,0 is top left of texture
#define TEXTURE_TRANSFER_FLAGS(format_in, format_out) \
    (GX_TRANSFER_FLIP_VERT(1) | GX_TRANSFER_OUT_TILED(1) | GX_TRANSFER_RAW_COPY(0) | \
    GX_TRANSFER_IN_FORMAT(format_in) | GX_TRANSFER_OUT_FORMAT(format_out) | \
    GX_TRANSFER_SCALING(GX_TRANSFER_SCALE_NO))

#define CLAMP(value, min, max) ((value < min) ? min : (value > max) ? max : value)

typedef struct
{
    int width, height;
} Surface;

typedef struct
{
    int width, height, real_width, real_height, bpp;
    C3D_Tex ptr;
} Texture;

typedef struct
{
    float left, top, right, bottom;
    Texture const * texture;
} Frame;

typedef struct
{
    int x, y, width, height;
    Frame const * frame;
} Sprite;

bool is_pow_2(u32 i)
{
    return i && !(i & (i - 1));
}

u32 next_pow_2(u32 i)
{
    i--;
    i |= i >> 1;
    i |= i >> 2;
    i |= i >> 4;
    i |= i >> 8;
    i |= i >> 16;
    i++;

    return (i < 64)
        ? 64 : i;
}

float easeLinear(int t, float b, float c, int d)
{
    return c * t / d + b;
}

void updateChip(Surface const * screen, Sprite * chip, Frame const * frames, u64 elapsed, circlePosition const * pos)
{
    int incr = 5;

    int dx = pos->dx;
    int dy = pos->dy;

    float x_incr = dx * incr / 160;
    float y_incr = dy * incr / 160;

    y_incr *= -1;

    chip->x += x_incr;
    chip->y += y_incr;

    chip->x = CLAMP(chip->x, 0, screen->width - chip->width);
    chip->y = CLAMP(chip->y, 0, screen->height - chip->height);

    int idx = easeLinear(elapsed % 1000, 0, 18, 1000);
    chip->frame = &frames[idx];
}

void setChipsFrames(Texture const * spritesheet, Frame * frames)
{
    if (!spritesheet->real_width || !spritesheet->real_height)
    {
        return ;
    }

    float texture_width = (float)spritesheet->width / spritesheet->real_width;
    float texture_height = (float)spritesheet->height / spritesheet->real_height;

    int nb_cols = 6, nb_rows = 3;

    float sprite_width = texture_width / nb_cols;
    float sprite_height = texture_height / nb_rows;

    float left = 0, top = 0;
    for (int i = 0; i < 18; ++i)
    {
        left = (i % nb_cols) * sprite_width;
        top = (int)(i / nb_cols) * sprite_height;

        frames[i].left = left;
        frames[i].top = top;
        frames[i].right = left + sprite_width;
        frames[i].bottom = top + sprite_height;
        frames[i].texture = spritesheet;
    }
}

void draw_quad(float x1, float y1, float x2, float y2, float tx1, float ty1, float tx2, float ty2)
{
    C3D_ImmDrawBegin(GPU_TRIANGLES);

    C3D_ImmSendAttrib(x1, y1, 0.5f, 0.0f);
    C3D_ImmSendAttrib(tx1, ty1, 0.0f, 0.0f);

    C3D_ImmSendAttrib(x2, y2, 0.5f, 0.0f);
    C3D_ImmSendAttrib(tx2, ty2, 0.0f, 0.0f);

    C3D_ImmSendAttrib(x2, y1, 0.5f, 0.0f);
    C3D_ImmSendAttrib(tx2, ty1, 0.0f, 0.0f);

    C3D_ImmSendAttrib(x1, y1, 0.5f, 0.0f);
    C3D_ImmSendAttrib(tx1, ty1, 0.0f, 0.0f);

    C3D_ImmSendAttrib(x1, y2, 0.5f, 0.0f);
    C3D_ImmSendAttrib(tx1, ty2, 0.0f, 0.0f);

    C3D_ImmSendAttrib(x2, y2, 0.5f, 0.0f);
    C3D_ImmSendAttrib(tx2, ty2, 0.0f, 0.0f);

    C3D_ImmDrawEnd();
}

static DVLB_s * vshader_dvlb;
static shaderProgram_s program;
static int uLoc_projection;
static C3D_Mtx projection;

static int loadImage(Texture * texture, u8 const * data, u32 size)
{
    // Configure buffers
    // C3D_BufInfo * bufInfo = C3D_GetBufInfo();
    // BufInfo_Init(bufInfo);

    int width, height;
    int bpp;

    unsigned char * image = stbi_load_from_memory(data, size, &width, &height, &bpp, 0);

    u32 pow2Width = !is_pow_2(width) ? next_pow_2(width) : width;
    u32 pow2Height = !is_pow_2(height) ? next_pow_2(height) : height;

    u32 texture_size = pow2Width * pow2Height * bpp;
    u8 * gpusrc = linearAlloc(texture_size);
    if (!gpusrc)
    {
        printf("Failed to alloc %lu", texture_size);
        return 1;
    }
    memset(gpusrc, 0, texture_size);

    // GX_DisplayTransfer needs input buffer in linear RAM
    // lodepng outputs big endian rgba so we need to convert
    for (int x = 0; x < width; x++)
    {
        for (int y = 0; y < height; y++)
        {
            u32 imagePos = (y * width + x) * bpp;
            u32 gpuTexPos = (y * pow2Width + x) * bpp;

            for (int c = 0; c < bpp; ++c)
            {
                gpusrc[gpuTexPos + c] = image[imagePos + (bpp - c - 1)];
            }
            // gpusrc[gpuTexPos + 0] = image[imagePos + 3];
            // gpusrc[gpuTexPos + 1] = image[imagePos + 2];
            // gpusrc[gpuTexPos + 2] = image[imagePos + 1];
            // gpusrc[gpuTexPos + 3] = image[imagePos + 0];
        }
    }

    // ensure data is in physical ram
    GSPGPU_FlushDataCache(gpusrc, texture_size);

    GPU_TEXCOLOR tex_color = 3 == bpp
        ? GPU_RGB8
        : GPU_RGBA8;

    u32 flags = 3 == bpp
        ? TEXTURE_TRANSFER_FLAGS(GX_TRANSFER_FMT_RGB8, GX_TRANSFER_FMT_RGB8)
        : TEXTURE_TRANSFER_FLAGS(GX_TRANSFER_FMT_RGBA8, GX_TRANSFER_FMT_RGBA8);

    C3D_TexInit(&texture->ptr, pow2Width, pow2Height, tex_color);

    // Convert image to 3DS tiled texture format
    u32 dim = GX_BUFFER_DIM(pow2Width, pow2Height);
    GX_DisplayTransfer(
        (u32 *)gpusrc, dim,
        (u32 *)texture->ptr.data, dim,
        flags
    );
    gspWaitForPPF();

    C3D_TexSetFilter(&texture->ptr, GPU_LINEAR, GPU_NEAREST);

    stbi_image_free(image);
    linearFree(gpusrc);

    texture->width = width;
    texture->height = height;
    texture->real_width = pow2Width;
    texture->real_height = pow2Height;
    texture->bpp = bpp;
    return 0;
}

static void sceneInit(Surface const * screen)
{
    // Load the vertex shader, create a shader program and bind it
    vshader_dvlb = DVLB_ParseFile((u32 *)vshader_shbin, vshader_shbin_size);
    shaderProgramInit(&program);
    shaderProgramSetVsh(&program, &vshader_dvlb->DVLE[0]);
    C3D_BindProgram(&program);

    // Get the location of the uniforms
    uLoc_projection = shaderInstanceGetUniformLocation(program.vertexShader, "projection");

    // Configure attributes for use with the vertex shader
    // Attribute format and element count are ignored in immediate mode
    C3D_AttrInfo * attrInfo = C3D_GetAttrInfo();
    AttrInfo_Init(attrInfo);
    AttrInfo_AddLoader(attrInfo, 0, GPU_FLOAT, 3); // v0=position
    AttrInfo_AddLoader(attrInfo, 1, GPU_FLOAT, 2); // v2=texcoord

    // Compute the projection matrix
    // Note: we're setting top to 240 here so origin is at top left.
    Mtx_OrthoTilt(&projection, 0.0, (float)screen->width, (float)screen->height, 0.0, 0.0, 1.0);

    // Configure the first fragment shading substage to just pass through the texture color
    // See https://www.opengl.org/sdk/docs/man2/xhtml/glTexEnv.xml for more insight
    C3D_TexEnv * env = C3D_GetTexEnv(0);
    C3D_TexEnvSrc(env, C3D_Both, GPU_TEXTURE0, 0, 0);
    C3D_TexEnvOp(env, C3D_Both, 0, 0, 0);
    C3D_TexEnvFunc(env, C3D_Both, GPU_REPLACE);

    // Configure depth test to overwrite pixels with the same depth (needed to draw overlapping sprites)
    C3D_DepthTest(true, GPU_GEQUAL, GPU_WRITE_ALL);

    // Update the uniforms
    C3D_FVUnifMtx4x4(GPU_VERTEX_SHADER, uLoc_projection, &projection);
}

static void sceneRender(Texture const * background, Sprite const * chip, float offset3d)
{
    if (background->real_width && background->real_height)
    {
        float texture_width = (float)background->width / background->real_width;
        float texture_height = (float)background->height / background->real_height;

        C3D_TexBind(0, &((Texture *)background)->ptr);
        draw_quad(
            0, 0, background->width, background->height,
            0.0f, 0.0f, texture_width, texture_height
        );
    }

    float x = chip->x + offset3d;
    C3D_TexBind(0, &((Texture *)((Frame *)chip->frame)->texture)->ptr);
    draw_quad(
        x, chip->y, x + chip->width, chip->y + chip->height,
        chip->frame->left, chip->frame->top, chip->frame->right, chip->frame->bottom
    );
}

static void sceneExit()
{
    // Free the shader program
    shaderProgramFree(&program);
    DVLB_Free(vshader_dvlb);
}

int main(int argc, char ** argv)
{
    Surface screen;
    screen.width = 400;
    screen.height = 240;

    // Initialize graphics
    gfxInitDefault();
    gfxSet3D(true);

    C3D_Init(C3D_DEFAULT_CMDBUF_SIZE);

    // Initialize the render target
    C3D_RenderTarget * top_left = C3D_RenderTargetCreate(screen.height, screen.width, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
    C3D_RenderTargetSetClear(top_left, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
    C3D_RenderTargetSetOutput(top_left, GFX_TOP, GFX_LEFT, DISPLAY_TRANSFER_FLAGS);

    C3D_RenderTarget * top_right = C3D_RenderTargetCreate(screen.height, screen.width, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
    C3D_RenderTargetSetClear(top_right, C3D_CLEAR_ALL, CLEAR_COLOR, 0);
    C3D_RenderTargetSetOutput(top_right, GFX_TOP, GFX_RIGHT, DISPLAY_TRANSFER_FLAGS);

    consoleInit(GFX_BOTTOM, NULL);
    printf("\x1b[15;10HPress Start to exit.");

    Sprite chip;
    chip.width = 45;
    chip.height = 45;
    chip.x = (screen.width - chip.width) / 2;
    chip.y = (screen.height - chip.height) / 2;
    chip.frame = NULL;

    Texture textures[2];

    bool loaded = (0 == loadImage(&textures[0], spritesheet_png, spritesheet_png_size))
        && (0 == loadImage(&textures[1], expresso_jpg, expresso_jpg_size));

    printf("\x1b[0;0H%d x %d -> %d x %d [%d]",
        textures[0].width, textures[0].height,
        textures[0].real_width, textures[0].real_height,
        textures[0].bpp
    );
    printf("\x1b[1;0H%d x %d -> %d x %d [%d]",
        textures[1].width, textures[1].height,
        textures[1].real_width, textures[1].real_height,
        textures[1].bpp
    );

    Frame frames[18];
    setChipsFrames(&textures[0], frames);

    // Initialize the scene
    sceneInit(&screen);

    circlePosition pos;

    // Main loop
    u64 start = osGetTime();
    while (aptMainLoop())
    {
        hidScanInput();

        // Respond to user input
        u32 kDown = hidKeysDown();
        if (kDown & KEY_START)
        {
            break; // break in order to return to hbmenu
        }

        if (!loaded)
        {
            continue;
        }

        //Read the CirclePad position
        hidCircleRead(&pos);
        // Print the CirclePad position
        printf("\x1b[2;0H%04d; %04d", pos.dx, pos.dy);

        u64 elapsed = osGetTime() - start;
        updateChip(&screen, &chip, frames, elapsed, &pos);

        float iod = osGet3DSliderState() * 15;
        if (iod > 0.0f)
        {
            printf("\x1b[3;0H3D enabled ");
        }
        else
        {
            printf("\x1b[3;0H3D disabled");
        }

        // Render the scene
        C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
        {
            if (iod > 0.0f)
            {
                C3D_FrameDrawOn(top_left);
                sceneRender(&textures[1], &chip, -iod);

                C3D_FrameDrawOn(top_right);
                sceneRender(&textures[1], &chip, iod);
            }
            else
            {
                C3D_FrameDrawOn(top_left);
                sceneRender(&textures[1], &chip, 0);
            }
        }
        C3D_FrameEnd(0);
    }

    // Deinitialize the scene
    sceneExit();

    for (int i = 0; i < 2; ++i)
    {
        C3D_TexDelete(&textures[i].ptr);
    }

    chip.frame = NULL;

    C3D_RenderTargetDelete(top_left);
    C3D_RenderTargetDelete(top_right);

    // Deinitialize graphics
    C3D_Fini();
    gfxExit();
    return 0;
}
